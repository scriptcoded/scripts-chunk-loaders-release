name: Create Release

on:
  push:
    branches:
      - main
      - 'mc/*'

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    # This condition prevents the workflow from running on pushes that
    # only contain the [skip ci] message from semantic-release itself.
    if: contains(github.event.head_commit.message, '[skip ci]') == false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - uses: gradle/actions/wrapper-validation@v4

      - uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'microsoft'

      - name: make gradle wrapper executable
        run: chmod +x ./gradlew

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "lts/*"

      - run: npm ci
      
      - name: Get Minecraft version
        id: mcVersion
        run: |
          PROPERTIES_FILE="gradle.properties"
          MC_VERSION_REGEX='minecraft_version\s*=\s*(.+)'

          MC_VERSION=$(grep -oP "$MC_VERSION_REGEX" "$PROPERTIES_FILE" | cut -d'=' -f2 | tr -d '[:space:]' || true)
          echo "version=$MC_VERSION" >> $GITHUB_OUTPUT

      - name: Release
        run: npx semantic-release
        env:
          MINECRAFT_VERSION: "${{ steps.mcVersion.outputs.version }}"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MODRINTH_TOKEN: ${{ secrets.MODRINTH_TOKEN }}

  # Because semantic-release also marks maintenance releases as latest,
  # we need to ensure that the highest semver release is marked as latest.
  promote-release:
    needs: release
    name: Mark highest semver as latest
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - run: npm ci
      - name: Find and mark latest release
        uses: actions/github-script@v7
        with:
          script: |
            const semver = require('semver');
            const { owner, repo } = context.repo;

            console.log(`Fetching all releases for ${owner}/${repo}...`);
            const { data: allReleases } = await github.rest.repos.listReleases({
              owner,
              repo,
            });

            const sortedReleases = allReleases
              .filter(r => !r.draft && !r.prerelease && semver.valid(r.tag_name))
              .sort((a, b) => semver.rcompare(a.tag_name, b.tag_name));

            if (sortedReleases.length === 0) {
              core.info("No valid, non-prerelease releases found. Exiting.");
              return;
            }

            const latestRelease = sortedReleases[0];
            console.log(`Highest semver release found: ${latestRelease.tag_name}`);

            console.log(`Updating release ${latestRelease.tag_name} to be the new 'latest' release.`);
            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: latestRelease.id,
              make_latest: 'true',
            });
            console.log(`Successfully marked ${latestRelease.tag_name} as the latest release.`);